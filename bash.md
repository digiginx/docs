# Аргументы скрипта
| | |
| --- | --- |
| `$0` | Имя скрипта |
| `$1` | Первый аргумент|
| `${n}` |                                                         |
| `$FUNCNAME` | |
| `$#`   | Количество аргументов скрипта                           |
| `$*` | Все аргументы скрипта (разделены пробелом)              |
| `$@` | Все аргументы скрипта (список)                          |
| `$?` | Статус выхода последней запущенной  программы (команды) |
| `$$` | PID запущенного скрипта                                 |
| `$!` | PID последнего запущенного в фоне процесса              |
## Обход всех аргументов скрипта
```bash
until [ -z "$1" ]
do
	echo "$1"
	shift
done
```
# Переменные
## Обращение к переменной
```bash
$a
${a}
"$a"
```
## Проверка на существование переменной
```bash
if [ -n $a ] ...
if [ -n "$2" ] ...
```
## Результат команды в переменную
```bash
result=`pwd`
result=$(pwd)
```
## Операции с ЧИСЛАМИ
| | |
|  --- | --- |
| `let "a = b + c"`             | Сумма            |
| `(( ВЫРАЖЕНИЕ ))` | Двойные круглые скобки позволяют работать с переменными в стиле языка C, |
| `(( a ++ ))` | |
| ` (( b = a<45?7:11 ))` | |
## Операции со СТРОКАМИ
| | |
| ---- | ---- |
| `${#str}`            | Длина строки `$str`, метод 1 |
| `expr length $str` | Длина строки `$str`, метод 2 |
| `${str:position}` | Извлечь символы из `$str`, начиная с позиции `$position`|
| `${str:position:length}` | Извлечь `$length` символов из `$str`, начиная с позиции `$position` |

# Условия
```bash
if [[ ]]
then

elif [[ ]]

else

fi
```
## Сравнение чисел
| | | |
| ---- | ---- | ---- |
| `[[ $a -eq $b ]]` | `(( a == b ))` | a = b |
| `[[ $a -ge $b ]]` | `(( a >= b ))` | a >= b |
| `[[ $a -gt $b ]]` | `(( a > b ))` | a > b |
| `[[ $a -le $b ]]` | `(( a <= b ))` | a <= b |
| `[[ $a -lt $b ]]` | `(( a <= b ))` | a < b |
| `[[ $a -ne $b ]]` | `(( a != b ))` | a != b |

## Сравнение строк
| | |
| ---- | ---- |
|`[[ -n "$str" ]]` | Длина строки `$str` больше нуля |
| `[[ -z "$str" ]]` | Длина строки `$str` равна нулю |
| `[[ "$str1" = "$str2" ]]` | Строки `$str1` и `$str2` идентичны |
| `[[ "$str1" != "$str2" ]]` | Строки `$str1` и `$str2` не идентичны |

## Проверка файлов и директорий
| | |
| ---- | ---- |
| `[[ -e "$a" ]]` | Файл существует (Все есть ФАЙЛ !!!) |
| `[[ -f "$a" ]]` | Файл существует и является обычным файловм |
| `[[ -d "$a" ]]` | Файл существует и является директорией |
| `[[ -b "$a" ]]` | Файл существует и является блочное устройством |
| `[[ -с "$a" ]]` | Файл существует и является символьным устройством |
| `[[ -p "$a" ]]` | Файл существует и является именованным каналом (FIFO) |
| `[[ -h "$a" ]]` | Файл существует и является символической ссылкой |
| `[[ -S "$a" ]]` | Файл существует и является сокетом |
| `[[ -r "$a" ]]` | Фаил существует и доступен для чтения |
| `[[ -s "$a" ]]` | Файл существует и не уст |
| `[[ -w "$a" ]]` | Файл существует и доступен для записи |
| `[[ -x "$a" ]]` | Файл существует и является исполняемым |
| `[[ -O "$a" ]]` | Файл существует и владелец текущий пользователь |
| `[[ -G "$a" ]]` | Файл существует и группа текущего пользователя |
| `[[ "$a" -nt "$b" ]]` | a новее b |
| `[[ "$a" -ot "$b" ]]` | a старше b |
# Циклы
## Цикл по заданным элементам
```bash
for (( i=0; i <= 10; i++ ))
do
  echo "$i"
done
```
```bash
list=( item1 item2 item3 )
for item in ${list[@]}; do
  echo "$item"
done
```
```bash
list="item1 item2 item3"
for item in $list; do
  echo ${item}
done
```
```bash
for item in {1..5}
do
  echo "$item"
done
```

## Цикл по файлам
```bash
# Вариант 1
for item in /tmp/*
do
  echo "file or dir: $item"
done
```
```bash
# Вариант2
find /tmp -name *.exe -exec echo {} \;
```

## Цикл по содержимогу файла
Чтобы изменить разделитель для цикла по файлу, необходимо изменить значение переменной IFS перед циклом
| | |
| ---- | ---- |
| `IFS=$'\n'` | перевод строки |
| `IFS=$'\t'`  | табуляция  |
| `IFS=:` | двоеточие |

```bash
for line in $(cat /tmp/file)
do
  echo "$line"
done
```
```bash
file=/tmp/file
while read line
do
  echo "$line"
done < $file
```
